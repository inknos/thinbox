#!/usr/bin/python3.10
# PYTHON_ARGCOMPLETE_OK

import argparse
import hashlib
import logging
import os
import re
import requests
import shutil
import subprocess
import sys

from distutils.sysconfig import get_python_lib
from sysconfig import get_config_var
from urllib.parse import urlparse

try:
    import argcomplete
    USE_ARGCOMPLETE = True
except ImportError:
    USE_ARGCOMPLETE = False


# dbox executable
THINBOX = os.path.basename(sys.argv[0])

# config directory according to XDG
XDG_CONFIG_HOME = os.environ.get("XDG_CONFIG_HOME", os.path.expanduser("~/.config"))
CONFIG_DIR = os.path.join(XDG_CONFIG_HOME, "thinbox")
USER_CONFIG = os.path.join(CONFIG_DIR, "user.thinbox.yaml")

# cache directory according to XDG
XDG_CACHE_HOME = os.environ.get("XDG_CACHE_HOME", os.path.expanduser("~/.cache"))
CACHE_DIR = os.path.join(XDG_CACHE_HOME, "thinbox")

# image directory and hashes
THINBOX_BASE_DIR = os.environ.get("THINBOX_BASE_DIR", os.path.join(CACHE_DIR, "base"))
THINBOX_IMAGE_DIR = os.environ.get("THINBOX_IMAGE_DIR", os.path.join(CACHE_DIR, "images"))
THINBOX_HASH_DIR  = os.environ.get("THINBOX_HASH_DIR",  os.path.join(CACHE_DIR, "hash"))

# virtual variables
THINBOX_MEMORY="1024"
THINBOX_SSH_OPTIONS="-o StrictHostKeyChecking=no -o GlobalKnownHostsFile=/dev/null -o UserKnownHostsFile=/dev/null"

# detect if running in a container
THINBOX_CONTAINER = os.environ.get("THINBOX_CONTAINER", "0") == "1"

# additional variables set inside a container
THINBOX_STACK = os.environ.get("THINBOX_STACK", None)
THINBOX_BASE_IMAGE_NAME = os.environ.get("THINBOX_BASE_IMAGE_NAME", None)
THINBOX_BASE_IMAGE_VERSION = os.environ.get("THINBOX_BASE_IMAGE_VERSION", None)

# environment variables used in the path tweaks
PATHS_ENV = {
    "PYTHON3_SITEARCH": get_python_lib(1),
    "PYTHON3_SITELIB": get_python_lib(),
    "LIBDIR": get_config_var("LIBDIR"),
}

# paths to be used in project path tweaks
PATHS = {
    "CMAKE_MODULE_PATH": ["/usr/share/cmake/Modules"],
    "CMAKE_PREFIX_PATH": ["/usr"],
    "CPATH": ["/usr/include"],
    "LD_LIBRARY_PATH": [PATHS_ENV["LIBDIR"]],
    "LIBRARY_PATH": [PATHS_ENV["LIBDIR"]],
    "PATH": ["/usr/sbin", "/usr/bin"],
    "PKG_CONFIG_PATH": [get_config_var("LIBPC")],
    "PKG_CONFIG_SYSTEM_INCLUDE_PATH": ["/usr/include"],
    "PYTHONPATH": [PATHS_ENV["PYTHON3_SITEARCH"], PATHS_ENV["PYTHON3_SITELIB"]],
}

RHEL_IMAGE_HASH = {
    "MD5SUM",
    "SHA1SUM",
    "SHA256SUM"
}
RHEL_IMAGE_DOMAIN = {
    "download-node-02.eng.bos.redhat.com",
    "redhat.com"
}

def _url_is_valid(url):
    """Validate a url format based on Django validator

    The validation is done through regex and it was taken from:
    https://stackoverflow.com/questions/7160737/how-to-validate-a-url-in-python-malformed-or-not
    https://github.com/django/django/blob/stable/1.3.x/django/core/validators.py#L45

    Parameters
    ----------
    url : str
        The url to validate

    Returns
    -------
    bool
        True if the url is valid
    """

    regex = re.compile(
        r'^(?:http|ftp)s?://' # http:// or https://
        r'(?:(?:[A-Z0-9](?:[A-Z0-9-]{0,61}[A-Z0-9])?\.)+(?:[A-Z]{2,6}\.?|[A-Z0-9-]{2,}\.?)|' #domain...
        r'localhost|' #localhost...
        r'\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})' # ...or ip
        r'(?::\d+)?' # optional port
        r'(?:/?|[/?]\S+)$', re.IGNORECASE)
    return re.match(regex, url) is not None

def _ping_url(url):
    """Ping a url to see if site is available

    Example from:
    https://stackoverflow.com/questions/316866/ping-a-site-in-python

    Parameters
    ----------
    url : str
        The url to ping

    Returns
    -------
    bool
        True if the ping has 0% packet loss
    """
    ping_response = subprocess.Popen(
        ["ping", "-c3", url],
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE)
    ping_stdout.stdout.read()
    ping_stderr.stderr.read()
    if ping_stderr != b'':
        logger.error("Ping error: {}".format(ping_stderr.decode('utf8')))
        sys.exit(1)
    result = ping_stdout.decode('utf-8')
    return "0% packet loss" in result

def is_virt_enabled():
    env = os.environ.copy()
    env["LC_LANG"] = "C"
    out = subprocess.run(["lscpu"], env=env, stdout=subprocess.PIPE)
    return "VT-x" in str(out.stdout)

class Thinbox(object):
    """
    A class made to represent a Thinbox run

    Attributes
    ----------
    url : str
        the url of the image to pull

    Methods
    -------
    pull(tag=None, url=None)
        Pulls a base image from a url or from a tag
    """
    def __init__(self):
        super().__init__()
        self._url = ""
        #self._os  = _detect_os_from_url(self.url)

    @property
    def url(self):
        return self._url

    @url.setter
    def url(self, val):
        # check if url is valid
        self._url = val

    def _detect_os_from_url(self, url):
        return None
        if url is None:
            return None
        domain = urlparse(url).netloc
        if domain in RHEL_IMAGE_DOMAIN:
            return "rhel"
        if domain in FEDORA_IMAGE_DOMAIN:
            return "fedora"

    def pull(self, tag=None, url=None):

        if tag:
            print("tag is", tag)

        if url:
            download_image(url)

    def image(self):
        self.image_list()

    def image_list(self):
        _image_list()

    def image_rm(self):
        pass

    def enter(self, name):
        _ssh_connect(name)

    def create(self):
        print("create")

    def create_from_image(self, base_name, name):

        if not os.path.exists(THINBOX_IMAGE_DIR):
            os.makedirs(THINBOX_IMAGE_DIR)
        image = os.path.join(THINBOX_IMAGE_DIR, name + ".qcow2")
        base = os.path.join(THINBOX_BASE_DIR, base_name)
        if not os.path.exists(base):
            logging.error("Image {} not found in {}.".format(base, THINBOX_BASE_DIR))

        # ensure_domain_undefined $name

        # ensure image does not exist

        p_qemu = subprocess.Popen([
            'qemu-img', 'create',
            '-f', 'qcow2', '-o',
            'backing_file='+ base +',backing_fmt=qcow2', image],
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE
        )
        logging.debug("qemu: {}".format(
            p_qemu.stdout.read()))
        logging.debug("qemu: {}".format(
            p_qemu.stderr.read()))

        p_virt_sysprep = subprocess.Popen([
            'virt-sysprep', '-a', image,
            '--hostname', name, '--ssh-inject', 'root',
            '--selinux-relabel'],
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE
        )
        logging.debug("virt-sysprep: {}".format(
            p_virt_sysprep.stdout.read()))
        logging.debug("virt-sysprep: {}".format(
            p_virt_sysprep.stderr.read()))

        p_virt_install = subprocess.Popen([
            'virt-install', '--network=bridge:virbr0',
            '--name', name, '--memory', THINBOX_MEMORY,
            '--disk', image,
            '--import',
            '--os-type=linux',
            '--os-variant=none',
            '--noautoconsole'],
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE
        )
        logging.debug("virt-install: {}".format(
            p_virt_install.stdout.read()))
        logging.debug("virt-install: {}".format(
            p_virt_install.stderr.read()))

def _get_mac(name):
    p_virsh = subprocess.Popen(['virsh', 'domiflist', name],
            stdout=subprocess.PIPE)
    mac = p_virsh.stdout.read().decode('utf8')
    return mac.strip()[-17:]

def _get_ip(name):
    mac = _get_mac(name)
    ip = ""
    with open("/proc/net/arp", "r") as arp:
        for line in arp:
            if mac in line:
                ip = line
                break
    #p_arp = subprocess.Popen(['arp', '-na'], stdout=subprocess.PIPE)
    #out = p_arp.stdout.read().decode('utf8')
    #ip = [ ip for ip in out.strip().split('\n') if mac in ip ][0]
    ip = re.findall( r'[0-9]+(?:\.[0-9]+){3}', ip )[0]
    logging.debug("Ip: {}".format(ip))
    return ip

def _ssh_connect(name):
    mac = _get_mac(name)
    ip = _get_ip(name)
    logging.debug("ip: {}".format(ip))
    logging.debug("mac: {}".format(mac))
    logging.debug("options: {}".format(THINBOX_SSH_OPTIONS))
    os.system("ssh {} root@{}".format(THINBOX_SSH_OPTIONS, ip))

def _image_list():
    image_list = []
    for root, dirs, files in os.walk(THINBOX_BASE_DIR):
        for file in files:
            image_list.append(file)
    print(THINBOX_BASE_DIR)
    print()
    print("{:<50} {:<20}".format("IMAGE", "HASH"))
    for name in image_list:
        print("{:<50} ".format(name), end="")
        none = True
        hashes = []
        for hashfunc in sorted(RHEL_IMAGE_HASH):
            if os.path.exists(os.path.join(THINBOX_HASH_DIR, name + "." + hashfunc + ".OK")):
                hashes.append(hashfunc)
                none = False
        if none:
            print("NONE", end="")
        else:
            print(",".join(hashes), end="")

        print()

def download_image(url):
    filename = os.path.split(url)[-1]
    filepath = os.path.join(THINBOX_BASE_DIR, filename)
    # check dir exist
    if not os.path.exists(CACHE_DIR):
        os.makedirs(CACHE_DIR)
    _download(url, filepath)
    #TODO download hash
    # this works for rhel
    if urlparse(url).netloc in RHEL_IMAGE_DOMAIN:
        print("HASH")
        hashpath = os.path.join(THINBOX_HASH_DIR, filename)
        for ext in RHEL_IMAGE_HASH:
            _download(url + "." + ext, hashpath + "." + ext)
    if check_hash(filename, "sha256"):
        print("Image downloaded, verified, and ready to use")
    else:
        print("Image downloaded and ready to use but not verified.")

def check_hash(filename, hashname="md5"):
    if hashname == "md5" or hashname == "md5sum":
        hashfunc = hashlib.md5()
        ext = "MD5SUM"
    elif hashname == "sha1" or hashname == "sha1sum":
        hashfunc = hashlib.sha1()
        ext = "SHA1SUM"
    elif hashname == "sha256" or hashname == "sha256sum":
        hashfunc = hashlib.sha256()
        ext = "SHA256SUM"
    else:
        logger.error("Not a valid hash function: {}".format(hashname))
    result, hh, hf = _check_hash(filename, ext, hashfunc)

    logging.debug("File hash is {}.".format(hf))
    logging.debug("Expected {} is {}.".format(hashname, hh))
    if not result:
        logging.info("Continue withouth hash verification")
        return result
    if not hh == hf:
        logging.error("Hashes do not match")
        sys.exit(1)

    return result

def _check_hash(filename, ext, hashfunc):
    """"This function returns the SHA-1 hash
    of the file passed into it"""
    h = hashfunc
    filepath = os.path.join(THINBOX_BASE_DIR, filename)
    hashpath = os.path.join(THINBOX_HASH_DIR, filename + "." + ext)
    if not os.path.exists(filepath):
        logging.error("Image file {} does not exists.".format(filepath))
        sys.exit(1)
    if not os.path.exists(hashpath):
        logging.error("Hash file {} does not exists.".format(filepath))
        return False, "", ""
    # if hash/imagename.hash.OK exists return True
    if os.path.exists(hashpath + ".OK"):
        with open(hashpath + ".OK", 'r') as file:
            file.readline()
            last = file.readline()
        hf = last.strip().split(' ')[-1]
        print("Found file that verifies a previous hash check for {}".format(ext))
        return True, hf, hf

    with open(hashpath, 'r') as file:
        file.readline()
        last = file.readline()
    with open(filepath,'rb') as file:
        chunk = 0
        while chunk != b'':
            chunk = file.read(1024)
            h.update(chunk)
    hh = h.hexdigest()
    hf = last.strip().split(' ')[-1]

    # if hash is good create hash/imagename.hash.OK
    if hh == hf:
        shutil.copyfile(hashpath, hashpath + ".OK")
    return hh == hf, hh, hf


def _download(url, filepath):
    # check file exist
    if os.path.exists(filepath):
        logging.debug("File {} exists.".format(filepath))
        return
    with open(filepath, 'wb') as f:
        response = requests.get(url, stream=True)
        total = response.headers.get('content-length')

        if total is None:
            f.write(response.content)
        else:
            downloaded = 0
            total = int(total)
            for data in response.iter_content(chunk_size=max(int(total/1000), 1024*1024)):
                downloaded += len(data)
                f.write(data)
                done = int(50*downloaded/total)
                sys.stdout.write('\r[{}{}]'.format('â–ˆ' * done, '.' * (50-done)))
                sys.stdout.flush()
    sys.stdout.write('\n')

def get_parser():
    """
    Returns a parser with this structure
    thinbox create
               |
               +-- -i/--image <image> <vm_name>
               +-- -p/--path  <path>  <vm_name>
               +-- -t/--tag   <image> <vm_name>
               +-- -u/--url   <url>   <vm_name>

    thinbox pull
             |
             +-- -t/--tag <tag>
             +-- -u/--url <url>

    thinbox image
              |
              +-- list/ls
              +-- remove/rm <image>
                        |
                        +-- -a
    thinbox
        |
        +-- list/ls
        +-- remove/rm <vm_name>
                  |
                  +-- -a

    thinbox vm
           |
           +-- list/ls
           +-- remove/rm <vm_name>
                     |
                     +-- -a

    thinbox enter <vm_name>
    thinbox start <vm_name>
    thinbox stop  <vm_name>
    """
    parser = argparse.ArgumentParser(#usage="%(prog)s <command> [opts] [args]",
        description="Thinbox is a tool for..",
        formatter_class=Formatter,
    )
    parser.add_argument(
            "-v",
            "--verbose",
            help="increase output verbosity",
            action="store_true"
    )

    subparsers = parser.add_subparsers(
        title="commands",
        dest="command",
    )

    pull_parser = subparsers.add_parser(
        "pull",
        help="pull base image from TAG or URL"
    )
    pull_parser_mg = pull_parser.add_mutually_exclusive_group(required=True)
    pull_parser_mg.add_argument(
        "-t", "--tag",
        help="TAG of the image you want to pull"
    )
    pull_parser_mg.add_argument(
        "-u", "--url",
        help="URL of the image you want to pull"
    )

    # create
    create_parser = subparsers.add_parser(
        "create",
        help="create VM from base image",
    )
    create_parser.add_argument(
        "name",
        help="name of the VM"
    )
    create_parser_mg = create_parser.add_mutually_exclusive_group(required=True)
    create_parser_mg.add_argument(
        "-i", "--image",
        help="Name of image already downloaded"
    )
    create_parser_mg.add_argument(
        "-p", "--path",
        help="Path of image you want to create a vm from"
    )
    create_parser_mg.add_argument(
        "-t", "--tag",
        help="TAG of the image you want to pull"
    )
    create_parser_mg.add_argument(
        "-u", "--url",
        help="URL of the image you want to pull"
    )

    # list
    list_parser = subparsers.add_parser(
        "list",
        help="list available VMs"
    )
    # remove
    remove_parser = subparsers.add_parser(
        "remove",
        help="remove VM"
    )
    # image
    image_parser = subparsers.add_parser(
        "image",
        help="manage base images"
    )
    # vm
    vm_parser = subparsers.add_parser(
        "vm",
        help="manage VMs"
    )
    # enter
    enter_parser = subparsers.add_parser(
        "enter",
        help="enter VM"
    )
    enter_parser.add_argument(
        "name",
        help="name of the VM to enter"
    )
    # start
    start_parser = subparsers.add_parser(
        "start",
        help="start VM"
    )
    start_parser.add_argument(
        "name",
        help="name of the VM to start"
    )
    # stop
    stop_parser = subparsers.add_parser(
        "stop",
        help="stop VM"
    )
    stop_parser.add_argument(
        "name",
        help="name of the VM to stop"
    )

    return parser


class Formatter(argparse.HelpFormatter):
    def _format_action(self, action):
        if isinstance(action, argparse._SubParsersAction):
            parts = []
            for i in action._get_subactions():
                parts.append("%*s%-21s %s" % (self._current_indent, "", i.metavar, i.help))
            return "\n".join(parts)
        return super(Formatter, self)._format_action(action)



def main():
    if not is_virt_enabled():
        print("Virtualization not enabled")
        exit(1)
    parser = get_parser()
    if USE_ARGCOMPLETE:
        argcomplete.autocomplete(parser)
    args = parser.parse_args()

    if args.verbose:
        logging.basicConfig(level=logging.DEBUG)

    if not args.command:
        parser.print_help()
        parser.error("Please specify a command")

    tb = Thinbox()
    if args.command == "pull":
        tb.pull(tag=args.tag, url=args.url)
    elif args.command == "image":
        tb.image()
    elif args.command == "create":
        if args.image:
            tb.create_from_image(args.image, args.name)
    elif args.command == "enter":
        tb.enter(args.name)


if __name__ == "__main__":
    try:
        main()
    except RuntimeError as ex:
        print("Error:", ex, file=sys.stderr)
        sys.exit(1)
    sys.exit(0)
