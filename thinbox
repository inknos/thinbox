#!/usr/bin/python3
# PYTHON_ARGCOMPLETE_OK

import argparse
import distutils.sysconfig
import hashlib
import logging
import os
import requests
import shutil
import subprocess
import sys

try:
    import argcomplete
    USE_ARGCOMPLETE = True
except ImportError:
    USE_ARGCOMPLETE = False


# dbox executable
THINBOX = os.path.basename(sys.argv[0])

# config directory according to XDG
XDG_CONFIG_HOME = os.environ.get("XDG_CONFIG_HOME", os.path.expanduser("~/.config"))
CONFIG_DIR = os.path.join(XDG_CONFIG_HOME, "thinbox")
USER_CONFIG = os.path.join(CONFIG_DIR, "user.thinbox.yaml")

# cache directory according to XDG
XDG_CACHE_HOME = os.environ.get("XDG_CACHE_HOME", os.path.expanduser("~/.cache"))
CACHE_DIR = os.path.join(XDG_CACHE_HOME, "thinbox")

# image directory and hashes
THINBOX_IMAGE_DIR = os.environ.get("THINBOX_IMAGE_DIR", os.path.join(CACHE_DIR, "images"))
THINBOX_HASH_DIR  = os.environ.get("THINBOX_HASH_DIR",  os.path.join(CACHE_DIR, "hash"))

# detect if running in a container
THINBOX_CONTAINER = os.environ.get("THINBOX_CONTAINER", "0") == "1"

# additional variables set inside a container
THINBOX_STACK = os.environ.get("THINBOX_STACK", None)
THINBOX_BASE_IMAGE_NAME = os.environ.get("THINBOX_BASE_IMAGE_NAME", None)
THINBOX_BASE_IMAGE_VERSION = os.environ.get("THINBOX_BASE_IMAGE_VERSION", None)

# environment variables used in the path tweaks
PATHS_ENV = {
    "PYTHON3_SITEARCH": distutils.sysconfig.get_python_lib(1),
    "PYTHON3_SITELIB": distutils.sysconfig.get_python_lib(),
    "LIBDIR": distutils.sysconfig.get_config_var("LIBDIR"),
}

# paths to be used in project path tweaks
PATHS = {
    "CMAKE_MODULE_PATH": ["/usr/share/cmake/Modules"],
    "CMAKE_PREFIX_PATH": ["/usr"],
    "CPATH": ["/usr/include"],
    "LD_LIBRARY_PATH": [PATHS_ENV["LIBDIR"]],
    "LIBRARY_PATH": [PATHS_ENV["LIBDIR"]],
    "PATH": ["/usr/sbin", "/usr/bin"],
    "PKG_CONFIG_PATH": [distutils.sysconfig.get_config_var("LIBPC")],
    "PKG_CONFIG_SYSTEM_INCLUDE_PATH": ["/usr/include"],
    "PYTHONPATH": [PATHS_ENV["PYTHON3_SITEARCH"], PATHS_ENV["PYTHON3_SITELIB"]],
}

RHEL_IMAGE_HASH = {
    "MD5SUM",
    "SHA1SUM",
    "SHA256SUM"
}

def is_virt_enabled():
    env = os.environ.copy()
    env["LC_LANG"] = "C"
    out = subprocess.run(["lscpu"], env=env, stdout=subprocess.PIPE)
    return "VT-x" in str(out.stdout)

class Thinbox(object):
    def __init__(self):
        super().__init__()

    def pull(self, tag=None, url=None):

        if tag:
            print("tag is", tag)

        if url:
            download_image(url)

    def image(self):
        self.image_list()

    def image_list(self):
        _image_list()

    def image_rm(self):
        pass

    def create(self):
        pass

def _image_list():
    image_list = []
    for root, dirs, files in os.walk(THINBOX_IMAGE_DIR):
        for file in files:
            image_list.append(file)
    print(THINBOX_IMAGE_DIR)
    print("Showing", len(image_list), "image/s.")
    print()
    for name in image_list:
        print(name)
        for hashfunc in sorted(RHEL_IMAGE_HASH):
            if os.path.exists(os.path.join(THINBOX_HASH_DIR, name + "." + hashfunc + ".OK")):
                print ("  {:<15} {:<10}".format(hashfunc, "OK"))
            else:
                print ("  {:<15} {:<10}".format(hashfunc, "NOTOK"))

def download_image(url):
    filename = os.path.split(url)[-1]
    filepath = os.path.join(THINBOX_IMAGE_DIR, filename)
    # check dir exist
    if not os.path.exists(CACHE_DIR):
        os.makedirs(CACHE_DIR)
    _download(url, filepath)
    #TODO download hash
    hashpath = os.path.join(THINBOX_HASH_DIR, filename)
    for ext in RHEL_IMAGE_HASH:
        _download(url + ext, "." + hashpath + ext)
    if check_hash(filename, "md5"):
        print("Image downloaded and ready to use")

def check_hash(filename, hash="md5"):
    if hash == "md5" or hash == "md5sum":
        hashfunc = hashlib.md5()
        ext = ".MD5SUM"
    result, hh, hf = _check_hash(filename, ext, hashfunc)

    if not result:
        logging.error("Hashes do not match")
    logging.debug("File hash is {}.".format(hf))
    logging.debug("Expected {} is {}.".format(hash, hh))
    return result

def _check_hash(filename, ext, hashfunc):
    """"This function returns the SHA-1 hash
    of the file passed into it"""
    #check hash file ok
    h = hashfunc
    filepath = os.path.join(THINBOX_IMAGE_DIR, filename)
    hashpath = os.path.join(THINBOX_HASH_DIR, filename + ext)
    if not os.path.exists(filepath):
        logging.warning("File {} does not exists.".filepath())
        return
    if not os.path.exists(hashpath):
        logging.warning("File {} does not exists.".format(filepath))
        return
    # if hash/imagename.hash.OK exists return True
    if os.path.exists(hashpath + ".OK"):
        with open(hashpath + ".OK", 'r') as file:
            file.readline()
            last = file.readline()
        hf = last.strip().split(' ')[-1]
        return True, hf, hf

    with open(hashpath, 'r') as file:
        file.readline()
        last = file.readline()
    with open(filepath,'rb') as file:
        chunk = 0
        while chunk != b'':
            chunk = file.read(1024)
            h.update(chunk)
    hh = h.hexdigest()
    hf = last.strip().split(' ')[-1]

    # if hash is good create hash/imagename.hash.OK
    if hh == hf:
        shutil.copyfile(hashpath, hashpath + ".OK")
    return hh == hf, hh, hf


def _download(url, filepath):
    # check file exist
    if not os.path.exists(filepath):
        _download(url, filepath)
    else:
        logging.debug("File {} exists.".format(filepath))
        return
    with open(filepath, 'wb') as f:
        response = requests.get(url, stream=True)
        total = response.headers.get('content-length')

        if total is None:
            f.write(response.content)
        else:
            downloaded = 0
            total = int(total)
            for data in response.iter_content(chunk_size=max(int(total/1000), 1024*1024)):
                downloaded += len(data)
                f.write(data)
                done = int(50*downloaded/total)
                sys.stdout.write('\r[{}{}]'.format('â–ˆ' * done, '.' * (50-done)))
                sys.stdout.flush()
    sys.stdout.write('\n')

def touch(fname):
    if os.path.exists(fname):
        os.utime(fname, None)
    else:
        open(fname, 'a').close()

def get_parser():
    """
    Returns a parser with this structure
    thinbox create
               |
               +-- -t/--tag <image> <vm_name>
               +-- -u/--url <url>   <vm_name>

    thinbox pull
             |
             +-- -t/--tag <tag>
             +-- -u/--url <url>

    thinbox image
              |
              +-- list/ls
              +-- remove/rm <image>
                        |
                        +-- -a
    thinbox
        |
        +-- list/ls
        +-- remove/rm <vm_name>
                  |
                  +-- -a

    thinbox vm
           |
           +-- list/ls
           +-- remove/rm <vm_name>
                     |
                     +-- -a
    thinbox enter <vm_name>
    thinbox start <vm_name>
    thinbox stop  <vm_name>
    """
    parser = argparse.ArgumentParser(#usage="%(prog)s <command> [opts] [args]",
        description="Thinbox is a tool for..",
        formatter_class=Formatter,
    )
    parser.add_argument(
            "-v",
            "--verbose",
            help="increase output verbosity",
            action="store_true"
    )

    subparsers = parser.add_subparsers(
        title="commands",
        dest="command",
    )

    pull_parser = subparsers.add_parser(
        "pull",
        help="pull base image from TAG or URL"
    )
    pull_parser_mg = pull_parser.add_mutually_exclusive_group(required=True)
    pull_parser_mg.add_argument(
        "-t", "--tag",
        help="TAG of the image you want to pull"
    )
    pull_parser_mg.add_argument(
        "-u", "--url",
        help="URL of the image you want to pull"
    )

    # create
    create_parser = subparsers.add_parser(
        "create",
        help="create VM from base image",
    )
    create_parser.add_argument(
        "name",
        help="name of the VM"
    )
    create_parser_mg = create_parser.add_mutually_exclusive_group(required=True)
    create_parser_mg.add_argument(
        "-t", "--tag",
        help="TAG of the image you want to pull"
    )
    create_parser_mg.add_argument(
        "-u", "--url",
        help="URL of the image you want to pull"
    )

    # list
    list_parser = subparsers.add_parser(
        "list",
        help="list available VMs"
    )
    # remove
    remove_parser = subparsers.add_parser(
        "remove",
        help="remove VM"
    )
    # image
    image_parser = subparsers.add_parser(
        "image",
        help="manage base images"
    )
    # vm
    vm_parser = subparsers.add_parser(
        "vm",
        help="manage VMs"
    )
    # enter
    enter_parser = subparsers.add_parser(
        "enter",
        help="enter VM"
    )
    enter_parser.add_argument(
        "name",
        help="name of the VM to enter"
    )
    # start
    start_parser = subparsers.add_parser(
        "start",
        help="start VM"
    )
    start_parser.add_argument(
        "name",
        help="name of the VM to start"
    )
    # stop
    stop_parser = subparsers.add_parser(
        "stop",
        help="stop VM"
    )
    stop_parser.add_argument(
        "name",
        help="name of the VM to stop"
    )

    return parser


class Formatter(argparse.HelpFormatter):
    def _format_action(self, action):
        if isinstance(action, argparse._SubParsersAction):
            parts = []
            for i in action._get_subactions():
                parts.append("%*s%-21s %s" % (self._current_indent, "", i.metavar, i.help))
            return "\n".join(parts)
        return super(Formatter, self)._format_action(action)



def main():
    if not is_virt_enabled():
        print("Virtualization not enabled")
        exit(1)
    parser = get_parser()
    if USE_ARGCOMPLETE:
        argcomplete.autocomplete(parser)
    args = parser.parse_args()

    if args.verbose:
        logging.basicConfig(level=logging.DEBUG)

    if not args.command:
        parser.print_help()
        parser.error("Please specify a command")
    if args.command == "pull":
        tb = Thinbox()
        tb.pull(tag=args.tag, url=args.url)
    elif args.command == "image":
        tb = Thinbox()
        tb.image()


if __name__ == "__main__":
    try:
        main()
    except RuntimeError as ex:
        print("Error:", ex, file=sys.stderr)
        sys.exit(1)
    sys.exit(0)
